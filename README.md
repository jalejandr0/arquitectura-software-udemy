# Arquitectura-Software-Udemy

https://www.udemy.com/course/arquitectura-software-moderna-ddd-eventos-microservicios-cqrs/

Elegir bien la arquitectura de tu sistema dependiendo de los requisitos necesarios es algo crítico y fundamental en el éxito de cualquier sistema software. Muchas veces, el no elegir la arquitectura correcta viene dado por el propio desconocimiento de las opciones que tenemos en nuestras manos.


Es por eso que te presento este curso de Arquitecturas de Software Modernas, donde veremos múltiples alternativas para organizar tu código de una forma adaptada a tus necesidades. Todas ellas con parte teórica, ejemplos prácticos y pros y contras, para que sepas cuándo utilizar cada una de ellas.



Arquitecturas convencionales: Empezaremos el curso viendo las arquitecturas más típicas, como puede ser la de tres capas, con el objetivo de tener un punto de partida y ver lo que nos pueden ofrecer las demás opciones.

Domain Driven Design (DDD): Continuaremos con el Domain Driven Design, módulo en el que veremos cómo diseñar nuestro sistema guiándonos por el dominio del problema que vamos a resolver, en lugar de guiarnos por los datos que queremos tratar, algo muy común en las arquitecturas convencionales.

Command Query Responsibility Segregation (CQRS): En el tercer módulo del curso veremos el CQRS, técnica que nos permitirá tratar las consultas (queries) y las escrituras (commands) de forma distinta, para optimizar ambas de la mejor forma y de manera independiente. Como veremos, tendremos paquetes, modelo e incluso Bases de Datos distintas para las dos operaciones.

Event Sourcing: Empezando con los eventos, veremos la técnica del Event Sourcing, que se basa en almacenar el estado actual como eventos, guardando todo lo que suceda en nuestro sistema, en lugar de guardar únicamente el estado actual.

Event Driven Programming: Técnica en la que la comunicación entre distintas entidades se realiza mediante el envío de eventos, en lugar de realizarse por llamadas directas a métodos. Como veremos, si extendemos esta técnica a más alto nivel, comunicando distintos subsistemas de nuestro sistema, tendremos la Event Driven Architecture.

Arquitectura Orientada a Microservicios: Arquitectura que se basa en dividir el dominio de nuestro problema en múltiples subdominios bien acotados, cada uno de ellos formando un microservicio. Es una de las arquitecturas más usadas hoy en día, ya que nos permite escalar nuestro sistema de una muy buena forma, haciendo que la disponibilidad del mismo sea mayor.

Arquitectura Hexagonal: Evolución del Domain Driven Design, con el objetivo de aislar aún más las capas internas de nuestro sistema, como son la capa de aplicación y la capa de dominio, de las tecnologías externas que utilicemos.

Arquitectura de Microkernel: También llamada arquitectura de plug-ins, ya que utiliza ese concepto como base de su arquitectura.

Arquitecturas Testables: Veremos cómo plantear correctamente los tests de tu sistema. Además, conoceremos todos los tipos de tests que deberías tener en mente a la hora de probar tu software, con consejos de cuándo utilizar cada uno de ellos.



Recalco que el objetivo de este curso no es el de ser expertos en todos estos temas, ya que para eso son necesarios años de experiencia. El objetivo aquí es conocer bien cada uno de ellos, con parte teórica, ejemplos prácticos y pros y contras, para que sepas a la perfección los detalles de cada técnica y cuándo utilizarlas.

